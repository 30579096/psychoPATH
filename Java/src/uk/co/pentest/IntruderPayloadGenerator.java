package uk.co.pentest.psychoPATH;

import burp.BurpExtender;
import burp.IBurpExtenderCallbacks;
import burp.IIntruderPayloadGenerator;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ListModel;

/**
 *
 * @author julianh
 */
public final class IntruderPayloadGenerator implements IIntruderPayloadGenerator 
{

    ArrayList<String> psychopaths; // the final payloads
    ArrayList<String> psychopaths_raw; // payloads before output encoding
    //static int pathInstances=0;
    int payloadIndex;    // counter for the payload mark       
    String payloadType;  // path or mark
    byte[] bytes_raw;    // byte payloads    
    ArrayList<String> bytes_out; // 
    IBurpExtenderCallbacks callbacks = BurpExtender.getBurpCallbacks();
    ArrayList<String> directoriesToCheck; // this is for the verification phase
    int payloadMarkerLength=7; // the lenght of the payload marker, a fixed length is safer while injecting into images etc.
    int resetCounter=0; // counts how many times reset() has been called iin this particular instance of the class
    // for some weird reason Intruder/Burp is calling reset() several (like four) times on the additional instance of the path generator
    // when it is used with another generator (other than mark) and it is the first generator
    // which leads to failure to generate full permutation for scenario like LFI ({path traversal payloads} + {byte payloads - terminators})
    // When the payload generators are declared (and therefore run) in the opposite order (byte first, path second), the problem does not occur
    // In order to get a workaround, I introduce a reset counter    
    PsychoTab tab;

    public IntruderPayloadGenerator(String payloadType, PsychoTab tab) 
    {
        this.payloadType = payloadType;
        this.tab=tab;
        
        if("byte".equals(payloadType))
        {
            int byteIndex=0;
            this.bytes_out=new ArrayList<>();
            /*
                    "non-alpha";
                    "alpha";
                    "non-alpha-print";
                    "non-alpha-non-print";
                    "all";
            */
            //this.bytes_raw=new ArrayList<>();
            if("non-alpha".equals(this.tab.psychoPanel.byteGeneratorRange))
            {
                this.bytes_raw = new byte[194];
                // 0-47     48
                // 58-64    7
                // 91-96    6
                // 123-255  133
                // 194 all together
                for(int i=0;i<48;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;
                }
                for(int i=58;i<65;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=91;i<97;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=123;i<256;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }            
            }
            if("alpha".equals(this.tab.psychoPanel.byteGeneratorRange))
            {
                // 48-57 -> 10
                // 65-90 -> 26
                // 97-122 -> 26
                // 62 altogether
                this.bytes_raw = new byte[62];
                for(int i=48;i<58;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;
                }
                for(int i=65;i<91;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=97;i<123;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
            }
            if("non-alpha-print".equals(this.tab.psychoPanel.byteGeneratorRange))
            {
                // 33-46 -> 14
                // 58-64 -> 7
                // 91-96 -> 6
                // 123-126 -> 4
                // 31 all together
                this.bytes_raw = new byte[31];
                for(int i=33;i<47;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;
                }
                for(int i=58;i<65;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=91;i<97;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=123;i<127;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }                
            }
            if("non-alpha-non-print".equals(this.tab.psychoPanel.byteGeneratorRange))
            {            
                // 0-31 -> 32
                // 127-255 -> 129
                // alltogether 161
                this.bytes_raw = new byte[161];
                for(int i=0;i<32;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
                for(int i=127;i<256;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
            }
            if("all".equals(this.tab.psychoPanel.byteGeneratorRange))
            {            
                // 0-255 -> 256
                this.bytes_raw = new byte[256];
                for(int i=0;i<256;i++)
                {
                    bytes_raw[byteIndex]=(byte)i;
                    byteIndex++;                
                }
            }            
            // now, check what the encodings are - and fill the bytes_out string array accordingly
            // we simply use the global psychoPATH encoding options
            ListModel encodeModel = this.tab.psychoPanel.encodeList.getModel();
            for(int j=0;j<this.bytes_raw.length;j++)
            {
                byte[] t = new byte[1];
                t[0]=this.bytes_raw[j];
                String convertedBytes = callbacks.getHelpers().bytesToString(t);
                for(int i=0;i<encodeModel.getSize();i++)
                {
                   if("None".equals(encodeModel.getElementAt(i).toString()))
                   { 
                       this.bytes_out.add(convertedBytes); // add the conversion here
                   }
                   if("URL".equals(encodeModel.getElementAt(i).toString())) // URL encode
                   {
                       try 
                       {                    
                           this.bytes_out.add(URLEncoder.encode(convertedBytes,StandardCharsets.UTF_8.toString()));
                       } 
                       catch (UnsupportedEncodingException ex) 
                       {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                   }
                   if("Double URL".equals(encodeModel.getElementAt(i).toString()))
                   {
                        try 
                        {                       
                           this.bytes_out.add(URLEncoder.encode(URLEncoder.encode(convertedBytes,StandardCharsets.UTF_8.toString())));
                        } 
                        catch (UnsupportedEncodingException ex) 
                        {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                        }
                   }
                }
            }                                                            
        }
        if("path".equals(this.payloadType)||"mark".equals(this.payloadType)) // "path" and "marker" generators
        {
            Set<String> targetDocroots; // this is a merge of the prefixes and targets
            ArrayList<String> brutDocrootSuffixes; // we'll also merge all targets into this
            ArrayList<String> traversals;
      
            ArrayList<String> unitTraversalsToUse;
            
            ArrayList<String> slashesToUse = new ArrayList<>();
            
            if(this.tab.psychoPanel.slashesToUse=="win")
            {
                slashesToUse.add("\\");
            }
            if(this.tab.psychoPanel.slashesToUse=="nix")
            {
                slashesToUse.add("/");
            }
            if(this.tab.psychoPanel.slashesToUse=="all")
            {
                slashesToUse.add("\\");
                slashesToUse.add("/");
            }
            
            
            // load basic traversals, according to the set of slashes to use
            unitTraversalsToUse = new ArrayList<>();
            for(int i=0;i<this.tab.psychoPanel.basicTraversals.size();i++)
            {
                unitTraversalsToUse.add(this.tab.psychoPanel.basicTraversals.get(i));

            }
            // load the evasive traversals, according to the set of slashes to use
            if(this.tab.psychoPanel.evasiveTechniques)
            {
                // read and decode the list of currently loaded breakup strings, if there are any
                ListModel breakupModel = this.tab.psychoPanel.breakupList.getModel();
                ArrayList<String> breakupStrings = new ArrayList<>();
                for(int i=0;i<breakupModel.getSize();i++)
                {
                    String asciihex=breakupModel.getElementAt(i).toString();
                    // ok, now we need to convert it back to characters and store in the breakupTraversals array
                    StringBuilder output = new StringBuilder();
                    for (int j = 0; j < asciihex.length(); j+=2) 
                    {
                        String str = asciihex.substring(j,j+2);
                        output.append((char)Integer.parseInt(str,16));
                    }
                    breakupStrings.add(output.toString());
                }
                
                ListModel evasiveTravModel = this.tab.psychoPanel.evasiveList.getModel();
                for (int i=0; i<evasiveTravModel.getSize(); i++) 
                {
                    String evasiveTraversal=evasiveTravModel.getElementAt(i).toString();
                    if(evasiveTraversal.contains("{BREAK}")) // we are dealing with a break-up sequence
                    {
                        // iterate over break-up strings and create variations
                        for(int j=0;j<breakupStrings.size();j++)
                        {
                            unitTraversalsToUse.add(evasiveTraversal.replace("{BREAK}", breakupStrings.get(j)));
                        }
                        // otherwise the traversal is ignored (not added to the unitTraversalsToUse arr list)
                    }
                    else
                    {
                        unitTraversalsToUse.add(evasiveTraversal);
                    }
                }  
 
            }
            String fileName;
            PsychoPanel panel=this.tab.getUiComponent();                        
            this.psychopaths = new ArrayList<>();
            this.psychopaths_raw = new ArrayList<>();           
            // generate all the payloads and put them into the arr
            targetDocroots = new HashSet<>();
            brutDocrootSuffixes = new ArrayList<>();
            traversals = new ArrayList<>(); 
            // 0) populate traversals and the filename           
            ArrayList<String> longestTraversals = new ArrayList<>();
            for(int i=0;i<unitTraversalsToUse.size();i++)
            {
                String baseTraversal = unitTraversalsToUse.get(i);
                String traversal=baseTraversal;
                for(int j=0;j<this.tab.psychoPanel.maxTraversalsPerPayload;j++)
                {
                    traversals.add(traversal);
                    if(j==this.tab.psychoPanel.maxTraversalsPerPayload-1) longestTraversals.add(traversal);
                    traversal=traversal+baseTraversal;
                }
            }
                    
            fileName=panel.fileNameField.getText();
      
            // 1) copy @brute_doc_root_prefixes to @target_docroots
            if(panel.LFImode==false) // whether to use the webroots at all
            {
                ListModel docListModel = panel.docrootsList.getModel();
            //if(docListModel==null) this.panel.stdout.println("The thing is empty...");
            
                for (int i=0; i<docListModel.getSize(); i++) 
                {
                    String targetDocroot=docListModel.getElementAt(i).toString();
                    // if the targetDocroot contains the {TARGET} holder
               
                    if(targetDocroot.contains("{TARGET}"))
                    {
                        // iterate over the targets 
                        // and create corresponding versions of the targetDocroot by substitution
                        ListModel targetListModel = panel.targetsList.getModel();
                   
                        for(int j=0;j<targetListModel.getSize();j++)
                        {
                             String target=targetListModel.getElementAt(j).toString();
                             String newTargetDocroot=targetDocroot.replace("{TARGET}",target);
                             targetDocroots.add(newTargetDocroot);
                        } 
                                        
                    }
                     // otherwise simply copy the targetDocroot                
                     else
                    {
                     targetDocroots.add(targetDocroot);     
                    }                
                }             
                // add the empty suffix
                brutDocrootSuffixes.add("");
                // 2.1) copy @targets to @brut_doc_suffixes
                ListModel targetListModel = panel.targetsList.getModel();
                for(int i=0;i<targetListModel.getSize();i++)
                {
                   String target=targetListModel.getElementAt(i).toString();
                   brutDocrootSuffixes.add(target);
                }                 
                // 2.2) copy @suffixes to @brut_doc_suffixes
                ListModel suffixListModel = panel.suffixesList.getModel();
                for(int i=0;i<suffixListModel.getSize();i++)
                {
                    String suffix=suffixListModel.getElementAt(i).toString();
                    brutDocrootSuffixes.add(suffix);
                }
                // 3.1) iterate through @targetDocroots -> 
                //        3.2)   iterate through @brute_doc_root_suffixes -> 
            //                3.3)      iterate through traversals -> 
            //                     3.4)              generate psychopaths
            }
            // 3.4.1 the bare filename with no prepended path injections
            this.psychopaths_raw.add(fileName);             
            // 3.4.2 the pure traversal + filename permutations (for upload directories hidden within the document root and LFI mode)
            if(panel.LFImode==true&&panel.optimizeLFI==true)
            {
                for(int i=0;i<longestTraversals.size();i++)        // 3.3
                {
                    String payload=longestTraversals.get(i)+"/"+fileName;
                    for(int j=0;j<slashesToUse.size();j++)
                    {
                        this.psychopaths_raw.add(payload.replace("/",slashesToUse.get(j)));      
                    }                    
                }
            }
            else
            {
                for(int i=0;i<traversals.size();i++)
                {
                    String payload=traversals.get(i)+"/"+fileName;
                    for(int j=0;j<slashesToUse.size();j++)
                    {
                        this.psychopaths_raw.add(payload.replace("/",slashesToUse.get(j))); 
                    }
                }
            }

            // 3.4.3 the targetDocroot+brutDocrootsuffix permutations 
            for(String targetDocRoot : targetDocroots) // 3.1
            {
                for(int i=0;i<brutDocrootSuffixes.size();i++) // 3.2
                {     
                    if(this.tab.psychoPanel.optimizeDocroots)
                    {
                        for(int j=0;j<longestTraversals.size();j++)        // 3.3
                        {
                          // if the docroot is windows-specific, we skip the letter for the traversal for it to work
                          String payload=longestTraversals.get(j)+targetDocRoot.replace("C:","")+"/"+brutDocrootSuffixes.get(i)+"/"+fileName;
                          for(int k=0;k<slashesToUse.size();k++)
                          {
                                this.psychopaths_raw.add(payload.replace("/",slashesToUse.get(k)));   
                          }
                        }
                    }
                    else
                    {
                        for(int j=0;j<traversals.size();j++)        // 3.3
                        {
                          String payload=traversals.get(j)+targetDocRoot.replace("C:","")+"/"+brutDocrootSuffixes.get(i)+"/"+fileName;
                          for(int k=0;k<slashesToUse.size();k++)
                          {
                                this.psychopaths_raw.add(payload.replace("/",slashesToUse.get(k)));
                          }
                        }
                    }
                    if(this.tab.psychoPanel.useAbsoluteWebroots)
                    {
                         ListModel drivesModel = panel.drivesList.getModel();                                                                          
                         String payload=targetDocRoot+"/"+brutDocrootSuffixes.get(i)+"/"+fileName;
                         for(int j=0;j<slashesToUse.size();j++)
                         {
                                String docroot=payload.replace("/",slashesToUse.get(j));
                                if(docroot.startsWith("C:"))
                                {
                                    for(int k=0;k<drivesModel.getSize();k++)
                                    {
                                         // if we are dealing with windows, we nee to make sure we use all drive the letters configured                                    
                                         this.psychopaths_raw.add(docroot.replace("C:",drivesModel.getElementAt(k).toString()+":"));                                 
                                    }  
                                }
                                else
                                {
                                    this.psychopaths_raw.add(docroot);
                                }
                         }                       
                    }
                }
            }                
            // now we have to deal with the output encodings
            ListModel encodeModel = this.tab.psychoPanel.encodeList.getModel();
            for(int j=0;j<this.psychopaths_raw.size();j++)
            {
                for(int i=0;i<encodeModel.getSize();i++)
                {
                   if("None".equals(encodeModel.getElementAt(i).toString()))
                   {
                       this.psychopaths.add(this.psychopaths_raw.get(j));
                   }
                   if("URL".equals(encodeModel.getElementAt(i).toString())) // URL encode
                   {
                       try {                    
                           this.psychopaths.add(URLEncoder.encode(this.psychopaths_raw.get(j),StandardCharsets.UTF_8.toString()));
                       } catch (UnsupportedEncodingException ex) {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                   }
                   if("Double URL".equals(encodeModel.getElementAt(i).toString()))
                   {
                        try {                       
                           this.psychopaths.add(URLEncoder.encode(URLEncoder.encode(this.psychopaths_raw.get(j),StandardCharsets.UTF_8.toString())));
                       } catch (UnsupportedEncodingException ex) {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                   }
                }
            }
        }
        if("check".equals(payloadType)&&this.directoriesToCheck==null)
        {
            this.directoriesToCheck=new ArrayList<>();
            this.directoriesToCheck=tab.psychoPanel.genericSuffixes; // we simply steal this list :)
        }
    }
    @Override
    public boolean hasMorePayloads() 
    {
        if("check".equals(this.payloadType))
        {
            return this.payloadIndex<this.directoriesToCheck.size();
        }
        if("mark".equals(this.payloadType)||"path".equals(this.payloadType))
        {
            return this.payloadIndex < this.psychopaths.size();
        }
        if("byte".equals(this.payloadType))
        {
            return this.payloadIndex < this.bytes_out.size();
        }
        return false; //unreachable statement
    }

    @Override
    public byte[] getNextPayload(byte[] baseValue) 
    {                
        byte[] payload  = new byte[0];
        if("mark".equals(this.payloadType))
        {
            // return the payload mark corresponding to the path payload, which is simply a unique string (number -> index)
            String prefix="";
            int ln = this.payloadMarkerLength-Integer.toString(this.payloadIndex).length();
            for(int i=0;i<ln;i++) prefix=prefix+"0";
            payload=callbacks.getHelpers().stringToBytes(prefix+Integer.toString(this.payloadIndex));
        }
        if("path".equals(this.payloadType))
        {
            // return the path payload
            payload = callbacks.getHelpers().stringToBytes(this.psychopaths.get(this.payloadIndex).toString());           
        }
        if("check".equals(this.payloadType))
        {
            payload = callbacks.getHelpers().stringToBytes(this.directoriesToCheck.get(this.payloadIndex).toString()); 
        }
        if("byte".equals(this.payloadType))
        {
            payload = this.callbacks.getHelpers().stringToBytes(this.bytes_out.get(this.payloadIndex).toString()); 
        }
        this.tab.psychoPanel.logOutput("Payload index "+this.payloadIndex+", payload type:"+this.payloadType);
        this.payloadIndex++; // increase the index
        return payload;
    }
    @Override
    public void reset() 
    {        
        payloadIndex = 0;
    }       
}